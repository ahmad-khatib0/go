package main

import (
	"sort"
	"testing"
	"testing/quick"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func FuzzGetSortedValues_ASC(f *testing.F) {
	input := map[int]string{99: "B", 0: "A"}

	// We add two fuzz testing arguments to the fuzz testing tool using the f.Add method, one for
	// the map key of the int type and one of the string type for the map value. These values
	// will be generated by the fuzzing tool. Both of these types are accepted for fuzzing arguments.
	f.Add(3, "W")

	f.Fuzz(func(t *testing.T, k int, v string) {
		input[k] = v
		keys := make([]int, 0, len(input))
		for k := range input {
			keys = append(keys, k)
		}

		sort.Ints(keys)
		// GetSortedValues is our UUT for this test
		sortedValues, err := GetSortedValues(input, ASC)
		require.Nil(t, err)
		require.NotNil(t, sortedValues)

		for index, v := range sortedValues {
			key := keys[index]
			assert.Equal(t, input[key], v)
		}
	})
}

// *******************************************************
//
//	Property-based testing
//
// *******************************************************
func TestGetSortedValues_ASC(t *testing.T) {
	input := map[int]string{99: "B", 0: "A"}

	// The real value of property-based testing, however, lies in its search
	// for failing function inputs, as opposed to generating fully random values(as fuzz test).
	isSorted := func(k int, val string) bool {
		input[k] = val
		keys := make([]int, 0, len(input))
		for k := range input {
			keys = append(keys, k)
		}

		sort.Ints(keys)
		sortedValues, err := GetSortedValues(input, ASC)
		if err != nil || sortedValues == nil {
			return false
		}

		for index, v := range sortedValues {
			key := keys[index]
			if input[key] != v {
				return false
			}
		}

		return true
	}

	// The Check functions of the quick package also take in a *quick.Config parameter that allows
	// us to configure our test run with the maximum number of iterations or another random generator.
	if err := quick.Check(isSorted, nil); err != nil {
		t.Error(err)
	}
}
