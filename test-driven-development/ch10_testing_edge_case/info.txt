- Fuzz testing is a powerful technique that has been used to find bugs in a wide variety of software
  systems, including the Go standard library itself. It involves generating a wide variety of values and
  using them as input to the UUT. The generated values stress-test the UUT and help uncover bugs or
  unexpected behavior such as panics, memory leaks, or incorrect outputs.
  Fuzz tests are automated, black-box tests that can be used to detect any potential functional or 
  security issues in our system. They are usually run using a fuzz tool, which takes care of value 
  generation, test execution, and error detection. 

- Writing fuzz tests is not very different from regular unit tests:
1- Identify the fuzz target: Just like with normal tests, we begin by identifying the UUT. The fuzz
   target will be the function that we will cover in our tests.
2- Identify fuzz arguments: The fuzz target is only suitable for fuzz testing if it takes in at least
   one parameter. These are the parameters that will be generated by the fuzz tool and used as
   input for the previously identified fuzz target.
3- Generate fuzzed values: Once the test is specified, the fuzz tool will begin to generate the
   random values for our fuzz arguments.
4- Run tests with fuzzed values: The tests are executed with the generated fuzzed values. Typically,
   fuzz tests are fast-running unit tests, as they will be run with a large amount of generated
   fuzzed values.
5- Report and log failures: The test runner will execute the tests, logging and reporting failures.
   Just like unit tests, fuzz tests can include assertions and verifications.

- Just like tests and benchmarks, fuzzed tests must follow a few rules:
1- Tests must begin with the Fuzz prefix. We notice that tests are exported functions, defined by 
   starting with a capital letter. For example, a fuzz test for our GetSortedValues function would 
   be named FuzzGetSortedValues.
2- Tests must be defined in test files named with the _test.go postfix. As with other test files, we
   should use the name of the source file to name our test file. For example, if our sorting function
   was defined in a sort.go file, then its corresponding test file could be sort_test.go.
3- Tests must accept a single *testing.F parameter and have no return values. This is the way fuzzed 
   tests interact with the test runner and fuzzing tool.
4- The fuzz target is defined by calling the Fuzz function on the *testing.F parameter. This function 
   takes in a *testing.T parameter, followed by the fuzzing arguments. There can only be one fuzz target
   per test and the calls on the UUT will happen inside the fuzz target.
5- Fuzz arguments are added to the fuzzing tool using the Add function on the *testing.F parameter. 
   This will instruct the tool to generate values to be used in the fuzz target. Fuzzing arguments 
   can be of the following types:
     1- string, []byte
     2- All int types, including rune
     3- All uint types, including byte
     5- All float types
     6- bool
6- Due to a large number of test runs, fuzz tests will be run in parallel. They should therefore
   be deterministic.
7- Fuzz tests are run alongside your other unit tests using the go test command or with the -fuzz
   flag followed by a test name or package. Again, this is similar to how we run benchmark tests.

- By default, the timeout for a fuzz target is 1 second, so your tests should be fast.

- Fuzzed tests will continue to run until a failing input is found or until the user cancels the 
  test run manually. Alternatively, we can supply a maximum execution time or the maximum number of
  iterations using the –fuzztime command-line parameter.

- go test -fuzz FuzzGetSortedValues_ASC -fuzztime 5s ./fragile-revised -v
 . elapsed indicates the amount of processing time
 . baseline coverage indicates the number of scenarios that are applied to measure the coverage 
   provided by the tests
 . execs indicates the number of test cases that have been run with the fuzz target
 . new interesting is the number of new inputs that are identified that expand the coverage
   of the fuzzed test

- The advantages of fuzz testing are as follows:
1- Easy to use and implement: As fuzzing integrates with Go’s testing package, we can easily write 
   fuzzed tests for anything in Go. However, it’s important to keep the scope of the tests small so 
   that they can be executed quickly and efficiently.
2- Can be used early in the development life cycle: As we have seen in our simple example, fuzzed tests 
   can be written for functions or even small units of code. This makes it easy to leverage them at any 
   stage of the development life cycle.
3- Detects a wide variety of bugs: Fuzzed testing generates values that cover edge cases and run over 
   many executions. This makes it a great tool for detecting bugs that would otherwise not have been 
   possible to find.

- The disadvantages of fuzz testing are as follows:
1- Does not replace traditional testing: Fuzzing complements rather than substitutes the types of tests 
   that we have explored throughout this book. Therefore, it can take additional engineering effort to
   write these tests.
2- Does not provide guarantees: Fuzzed tests only provide an indication of the stability of the UUT, 
   not a guarantee. As it generates random values, it can only indicate to developers the presence of
   bugs for the inputs it does cover.
3- Memory- & CPU-intensive: As we have seen from our example output, fuzzed tests are run in parallel 
   over a large number of scenarios. This makes them more memory- and CPU-intensive than unit tests.
4- We do not have any control over the random inputs. This leads to two problems:
   . We test a large number of irrelevant scenarios that are unlikely to happen in our system.
   . We don’t know whether the scenarios that really matter have been covered by our fuzzed tests.
     Instead, it would be great if we had a more structured approach available to us.

Property-based testing 
  is a testing technique that involves testing a program against a set of properties or specifications 
  that are important to our user journeys and system behavior. This allows engineers to follow a systemic
  approach to testing, as opposed to focusing on verifying inputs. In property-based testing, we generate
  random inputs that satisfy the set of constraints or properties that we have identified. The generation
  aspect ensures that we test against a larger space of edge cases than would have been possible with 
  traditional, manually written tests. The focus on properties ensures that we cover the edge cases that
  matter to our applications. Again, this does not guarantee the absence of bugs, but it does ensure 
  that we spend our time testing the things that matter.

- The testing/quick package offers testing helper functionality that we can leverage to implement
  property-based tests:
. The quick.Check function takes in a function with a bool return value and searches for arbitrary 
  values that make the input function return false.
. The quick.CheckEqual function takes in two functions and looks for an input for which the functions 
  return different results.
. The quick.Generator interface defines a Generate method that custom types can implement. Once they 
  satisfy this interface, we can generate random values for our custom types using the quick.Value 
  function. This gives us the flexibility to generate values for any exported type.

