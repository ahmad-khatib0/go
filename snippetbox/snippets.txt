
┌──────┐
  HTTP 
└──────┘
# Set a new cache-control header. If an existing "Cache-Control" header exists it will be overwritten.
 w.Header().Set("Cache-Control", "public, max-age=31536000")
   
# In contrast, the Add() method appends a new "Cache-Control" header and can be called multiple times.
w.Header().Add("Cache-Control", "public")
w.Header().Add("Cache-Control", "max-age=31536000")

w.Header().Del("Cache-Control") // Delete all values for the "Cache-Control" header.

w.Header().Get("Cache-Control") // Retrieve the first value for the "Cache-Control" header.

mux := http.NewServeMux()

mux.Handle("/", http.HandlerFunc(home))  # this is equivalent to: 
mux.HandleFunc("/", home)                # 


-- It’s important to know that when the last handler in the chain returns, control is passed back up the chain in 
    the reverse direction. So when our code is being executed the flow of control actually looks like this:
    secureHeaders → servemux → application handler → servemux → secureHeaders
    -- In any middleware handler, code which comes before next.ServeHTTP() will be executed on the way down the chain, 
    -- and any code after next.ServeHTTP() — or in a deferred function — will be executed on the way back up.
    
      func myMiddleware(next http.Handler) http.Handler {
        
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
          // Any code here will execute on the way down the chain.
        
        next.ServeHTTP(w, r)
           // Any code here will execute on the way back up the chain.
        })
      }

--  ----------- TLS -------------
--  go run /usr/local/go/src/crypto/tls/generate_cert.go --rsa-bits=2048 --host=localhost

we could redirect the stdout and stderr streams to on-disk files when starting the application like so:
go run cmd/web/* >>/tmp/info.log 2>>/tmp/error.log 

┌──────────┐
  Database 
└──────────┘

CREATE USER 'web'@'localhost'; GRANT
SELECT INSERT ON
    snippetbox.* TO 'web'@'localhost';
    -- Important: Make sure to swap 'pass' with a password of your own choosing.
ALTER
    USER 'web'@'localhost' IDENTIFIED BY 'pass';

┌────────────┐
  Templating 
└────────────┘
{{with .Foo}} C1 {{else}} C2 {{end}}
- If .Foo is not empty, then set dot to the value of .Foo and render the content C1, otherwise render the content C2.

{{range .Foo}} C1 {{else}} C2 {{end}}
- If the length of .Foo is greater than zero then loop over each element, setting dot to the value of each element and 
   rendering the content C1. If the length of .Foo is zero then render the content C2. The underlying type of .Foo 
   must be an array, slice, map, or channel.

{{$exp := or (.FormData.Get "expires") "365"}}
# we used () parenth to group the .FormData.Get method and its params in order to pass its output to the or action 


{{eq .Foo .Bar}}                Yields true if .Foo is equal to .Bar
{{ne .Foo .Bar}}                Yields true if .Foo is not equal to .Bar
{{not .Foo}}                    Yields the boolean negation of .Foo
{{or .Foo .Bar}}                Yields .Foo if .Foo is not empty; otherwise yields .Bar
{{index .Foo i}}                Yields the value of .Foo at index i. The underlying type of .Foo must be a map, slice or array.
{{len .Foo}}                    Yields the length of .Foo as an integer.
{{$bar := len .Foo}}            Assign the length of .Foo to the template variable $bar
{{printf "%s-%s" .Foo .Bar}}    Yields a formatted string containing the .Foo and .Bar values. Works in the same way as
                                fmt.Sprintf().


