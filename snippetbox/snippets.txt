// Set a new cache-control header. If an existing "Cache-Control" header exists it will be overwritten.
   w.Header().Set("Cache-Control", "public, max-age=31536000")
   
// In contrast, the Add() method appends a new "Cache-Control" header and can be called multiple times.
w.Header().Add("Cache-Control", "public")
w.Header().Add("Cache-Control", "max-age=31536000")

// Delete all values for the "Cache-Control" header.
w.Header().Del("Cache-Control")

// Retrieve the first value for the "Cache-Control" header.
w.Header().Get("Cache-Control")

mux := http.NewServeMux()

mux.Handle("/", http.HandlerFunc(home))  # this is equivalent to: 
mux.HandleFunc("/", home)                # 

we could redirect the stdout and stderr streams to on-disk files when starting the application like so:
go run cmd/web/* >>/tmp/info.log 2>>/tmp/error.log 

CREATE USER 'web'@'localhost'; GRANT
SELECT INSERT ON
    snippetbox.* TO 'web'@'localhost';
    -- Important: Make sure to swap 'pass' with a password of your own choosing.
ALTER
    USER 'web'@'localhost' IDENTIFIED BY 'pass';


{{with .Foo}} C1 {{else}} C2 {{end}}
- If .Foo is not empty, then set dot to the value of .Foo and render the content C1, otherwise render the content C2.

{{range .Foo}} C1 {{else}} C2 {{end}}
- If the length of .Foo is greater than zero then loop over each element, setting dot to the value of each element and 
   rendering the content C1. If the length of .Foo is zero then render the content C2. The underlying type of .Foo 
   must be an array, slice, map, or channel.

{{eq .Foo .Bar}}                Yields true if .Foo is equal to .Bar
{{ne .Foo .Bar}}                Yields true if .Foo is not equal to .Bar
{{not .Foo}}                    Yields the boolean negation of .Foo
{{or .Foo .Bar}}                Yields .Foo if .Foo is not empty; otherwise yields .Bar
{{index .Foo i}}                Yields the value of .Foo at index i. The underlying type of .Foo must be a map, slice or array.
{{len .Foo}}                    Yields the length of .Foo as an integer.
{{$bar := len .Foo}}            Assign the length of .Foo to the template variable $bar
{{printf "%s-%s" .Foo .Bar}}    Yields a formatted string containing the .Foo and .Bar values. Works in the same way as
                                fmt.Sprintf().
