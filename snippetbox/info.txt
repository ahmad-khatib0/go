
┌──────┐
  HTTP 
└──────┘
You might sometimes see network addresses written using named ports like ":http" or ":http-alt"
    instead of a number. If you use a named port then Go will attempt to look up the relevant port 
    number from your /etc/services file when starting the server,

Pattern "/" is an example of a subtree path (because it ends in a trailing slash). Another example would 
    be something like "/static/". Subtree path patterns are matched (and the corresponding handler called) 
    whenever the start of a request URL path matches the subtree path. If it helps your understanding, you can 
    think of subtree paths as acting a bit like they have a wildcard at the end, like "/**" or "/static/**".

http.HandleFunc("/snippet/create", createSnippet) 
  # These allow you to register routes without declaring a servemux, Behind the scenes, these functions 
    register their routes with something called the DefaultServeMux , DON'T do that Because DefaultServeMux 
    is a global variable, any package can access it and register a route — including any third-party packages 
    that your application imports. If one of those third-party packages is compromised, they could use 
    DefaultServeMux to expose a malicious handler to the web.

-- Request URL paths are automatically sanitized, if a user makes a request to /foo/bar/..//baz they 
   will automatically be sent a 301 Permanent Redirect to /foo/baz instead.
--  if you have registered the subtree path /foo/, then any request to /foo will be redirected to /foo/

-- servemux is pretty lightweight. It doesn’t support routing based on the request method, it 
   doesn’t support semantic URLs with variables in them, and it doesn’t support regexp-based patterns
   
-- It’s only possible to call w.WriteHeader() once per response, and after the status code has been 
   written it can’t be changed. If you try to call w.WriteHeader() a second time Go will log a warning message
   
-- If you don’t call w.WriteHeader() explicitly, then the first call to w.Write() will automatically send 
   a 200 OK status code to the user. So, if you want to send a non-200 status code, you must call
   w.WriteHeader() before any call to w.Write().
   
-- The http.DetectContentType() function generally works quite well, but it can’t distinguish JSON from 
   plain text. And, by default, JSON responses will be sent with a Content-Type: text/plain; charset=utf-8

-- the header name will always be canonicalized using the textproto.CanonicalMIMEHeaderKey() function. 
   This converts the first letter and any letter following a hyphen to uppercase, and the rest to lowercase

--  When headers are written to a HTTP/2 connection the header names and values 
    will always be converted to lowercase, as per the specifications.

.. Go’s file server has a few really nice features: 
-- It sanitizes all request paths by running them through the path.Clean() function before searching for a 
   file. This removes any . and .. elements from the URL path, which helps to stop directory traversal attacks. 
-- Range requests are fully supported. This is great if your application is
   serving large files and you want to support resumable downloads
-- The Last-Modified and If-Modified-Since headers are transparently supported. If a file hasn’t changed 
   since the user last requested it, then http.FileServer will send a 304 Not Modified status code instead 
   of the file itself. This helps reduce latency and processing overhead for both the client and server.

-- Ports 0-1023 are restricted and (typically) can only be used by services which have root privileges

┌────────────┐
  Templating 
└────────────┘
-- {{define "base"}}...{{end}} action to define a distinct named template called base

-- the dot at the end of the {{template "title" .}} action represents any 
   dynamic data that you want to pass to the invoked template

-- Go also provides a {{block}}...{{end}} action, This acts like the {{template}} action, except it allows 
   you to specify default content if the template being invoked doesn’t exist in the current template set.


-- If you run the go mod verify command from your terminal, this will verify that the checksums of the downloaded packages 
   on your machine match the entries in go.sum, so you can be confident that they haven’t been altered.
-- If someone else needs to download all the dependencies for the project — which they can do by running go mod download 
   get an error if there is any mismatch between the dependencies they are downloading and the checksums in the file.they will
-- go get github.com/foo/bar@none , prefixing it wi @none will remove this unwanted package 

-- The parseTime=true is a driver-specific param which instructs our driver to convert SQL TIME and DATE fields to Go time.Time objects.
-- The sql.Open() function returns a sql.DB object. This isn’t a database connection — it’s a pool of many connections. 
   Go manages these connections as needed, automatically opening and closing connections to the database via the drive
-- The connection pool is safe for concurrent access, so you can use it from web application handlers safely.

-- _ "github.com/go-sql-driver/mysql" 

      Notice how the import path for our driver is prefixed with an underscore? This is because our main.go file doesn’t
      actually use anything in the mysql package. So if we try to import it normally the Go compiler will raise an error.
      However, we need the driver’s init() function to run so that it can register itself with the database/sql package. 
      The trick to getting around this is to alias the package name to the blank identifier. This is standard practice 
      for most of Go’s SQL drivers.
