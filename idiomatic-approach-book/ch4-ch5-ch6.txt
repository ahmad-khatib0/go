*************************************************************************************** 
********************************* Shadowing Variables ********************************* 
*************************************************************************************** 

- A shadowing variable is a variable that has the same name as a variable in a containing block. 
For as long as the shadowing variable exists, you cannot access a shadowed variable 
- Once the local variable fmt is declared, it shadows the package named fmt in (THE FILE BLOCK),
making it impossible to use the fmt package for the rest of the main function


*************************************************************************************** 
********************************* If Block ******************************************** 
*************************************************************************************** 
- Be aware that just like any other block, a variable declared as part of an if statement will
shadow variables with the same name that are declared in containing blocks


*************************************************************************************** 
********************************* For loop ******************************************** 
*************************************************************************************** 
- for is the only looping keyword in the language. Go accomplishes this by using the for keyword in four different format
    1. A complete, C-style for
    2. A condition-only for
    3. An infinite for
    4. for-range

- Why the order of the key an values may vary ? 
The order of the keys and values varies; some runs may be identical. This is actually a security feature. 
In earlier Go versions, the iteration order for keys in a map was usually (but not always) the same if you 
inserted the same items into a map. This caused two problems. 
 1- People would write code that assumed that the order was fixed, and this would break at weird times. 
 2- If maps always hash items to the exact same values, and you know that a server is storing some user data 
 in a map, you can actually slow down a server with an attack called Hash DoS by sending it specially crafted 
 data where all of the keys hash to the same bucket.
To prevent both of these problems, the Go team made two changes to the map implementation. First, they modified 
the hash algorithm for maps to include a random number that’s generated every time a map variable is created. 
Next, they made the order of a for-range iteration over a map vary a bit each time the map is looped over. 
These two changes make it far harder to implement a Hash DoS attack. 



*************************************************************************************** 
********************************* Ignoring returned values **************************** 
*************************************************************************************** 
Surprisingly, Go does let you implicitly ignore all of the return values for a function. You can write 
divAndRemainder(5,2) and the returned values are dropped. We have actually been doing this since our 
earliest examples: fmt.Println returns two values, but it is idiomatic to ignore them. In almost
all other cases, you should make it explicit that you are ignoring return values by using underscores.

*************************************************************************************** 
************************************* Defers ****************************************** 
*************************************************************************************** 
1- you can defer multiple closures in a Go function. They run in last-in-first-out order; the
last defer registered runs first.
2- The code within defer closures runs after the return statement, you can supply a function with input 
parameters to a defer. Just as defer doesn’t run immediately, any variables passed into a deferred 
closure aren’t evaluated until the closure runs.


*************************************************************************************** 
************************************* Call By Value *********************************** 
*************************************************************************************** 
-- any changes made to a map parameter are reflected in the variable passed in to the function. For a slice, it’s
more complicated. You can modify any element in the slice, but you can’t lengthen the slice. This is true for 
maps and slices that are passed directly into function as well as map and slice fields in structs.
-- why do maps and slices behave differently than other types? It’s because maps and slices 
are both implemented with pointers


                               THE UNIVERSE BLOCK
There’s actually one more block which is a little weird: the universe block. Go is a small language with 
(ONLY 25 KEYWORDS). What’s interesting is that the built-in types (like int and string), constants 
(like true and false), and functions (like make or close) aren’t included in that list. Neither is nil. 
So, where are they?  Rather than make them keywords, Go considers these predeclared identifiers and defines 
them in the universe block, which is the block that contains all other blocks.  Because these names 
are declared in the universe block, it means that they can be shadowed in other scope
for example like!!: true := 10


*************************************************************************************** 
************************************** Pointers *************************************** 
*************************************************************************************** 
-- you only need a bit to represent true or false, but the smallest amount of 
   memory that can be independently addressed is a byte
-- While different types of variables can take up different numbers of memory
   locations, every pointer, no matter what type it is pointing to, is always the same size
-- The & is the address operator. It precedes a value type and returns the address of
   the memory location where the value is stored
-- The * is the indirection operator. It precedes a variable of pointer type and
   returns the pointed-to value. This is called dereferencing.
-- Before dereferencing a pointer, you must make sure that the pointer is non-nil.
   Your program will panic if you attempt to dereference a nil pointer.
-- The built-in function new creates a pointer variable. It returns a pointer to a
   zero-value instance of the provided type.
-- The new function is rarely used. For structs, use an & before a struct literal to create a pointer instance.
   You can’t use an & before a primitive literal (numbers, booleans, and strings) or a constant because they don’t 
   have a memory address; they only exist at compile time. When you need a pointer to a primitive type, 
   declare a variable and point to it
--  If you have a struct with a field of a pointer to a primitive type, you can’t assign a literal directly to the field
-- when you pass a nil pointer to a function, you cannot make the value non-nil. You can only reassign the value if
   there was a value already assigned to the pointer
-- The Unmarshal function populates a variable from a slice of bytes containing JSON. It is declared to take a slice 
   of bytes and an interface{} parameter. The value passed in for the interface{} parameter must be a pointer. If it is
   not, an error is returned. This pattern is used because Go doesn’t have generics.
   That means there isn’t a convenient way to pass a type into a function to specify
   what to unmarshal into nor is there a way to specify a different return type for different types

-- The lack of immutable declarations in Go might seem problematic, but the ability to choose between value and pointer 
   parameter types addresses the issue. As the Software Construction course materials go on to explain: “[U]sing
   mutable objects is just fine if you are using them entirely locally within a method, and with only one reference to the 
   object.” Rather than declare that some variables and parameters are immutable, Go developers use pointers to
   indicate that a parameter is mutable.
