********************************* Terms ********************************* 
-An abstract type is one that specifies what a type should do, but not how it is done. 
-A concrete type specifies how and what. This means that it has a specified way to store its data and provides an
  implementation of any methods declared on the type. While all types in Go are either abstract or concrete, 
  some languages allow hybrid types, such as abstract classes or interfaces with default methods in Java

-- By convention, the receiver name (p Person) is a short abbreviation of the type’s name, usually 
   its first letter. It is non-idiomatic to use this or self.
-- Just like functions, method names cannot be overloaded. You can use the same method names for different types, 
   but you can’t use the same method name for two different methods on the same type

************************************************************************* 
********************************* Methods *******************************
*************************************************************************
-- Pointer Receivers and Value Receivers: 
  . If your method modifies the receiver, you must use a pointer receiver.
  . If your method needs to handle nil instances, then it must use a pointer receiver.
  . If your method doesn’t modify the receiver, you can use a value receiver. 

var c Counter   
fmt.Println(c.String()) // String is a pointer receiver!!? => total: 0, last updated: 0001-01-01 00:00:00 +0000 UTC
-- One thing you might notice is that we were able to call the pointer receiver!!
   method even though c is a value type. When you use a pointer receiver with a local variable that’s a value type,
   Go automatically converts it to a pointer type. In this case, c.String() is converted to (&c).String()..
   NOTE: be aware that the rules for passing values to functions still apply. If you pass a value type to a
   function, and call a pointer receiver method on the passed value, you are invoking the method on a copy
-- if you change the copy of the pointer, you haven’t changed the original. This means => you can’t write a pointer
   receiver method that handles nil and makes the original pointer non-nil. If your method has a pointer receiver 
   and won’t work for a nil receiver, check for nil and return an error