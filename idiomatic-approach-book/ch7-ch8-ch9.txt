********************************* Terms ********************************* 
-An abstract type is one that specifies what a type should do, but not how it is done. 
-A concrete type specifies how and what. This means that it has a specified way to store its data and provides an
  implementation of any methods declared on the type. While all types in Go are either abstract or concrete, 
  some languages allow hybrid types, such as abstract classes or interfaces with default methods in Java

-- By convention, the receiver name (p Person) is a short abbreviation of the type’s name, usually 
   its first letter. It is non-idiomatic to use this or self.
-- Just like functions, method names cannot be overloaded. You can use the same method names for different types, 
   but you can’t use the same method name for two different methods on the same type

************************************************************************* 
********************************* Methods *******************************
*************************************************************************
-- Pointer Receivers and Value Receivers: 
  . If your method modifies the receiver, you must use a pointer receiver.
  . If your method needs to handle nil instances, then it must use a pointer receiver.
  . If your method doesn’t modify the receiver, you can use a value receiver. 

var c Counter   
fmt.Println(c.String()) // String is a pointer receiver!!? => total: 0, last updated: 0001-01-01 00:00:00 +0000 UTC
-- One thing you might notice is that we were able to call the pointer receiver!!
   method even though c is a value type. When you use a pointer receiver with a local variable that’s a value type,
   Go automatically converts it to a pointer type. In this case, c.String() is converted to (&c).String()..
   NOTE: be aware that the rules for passing values to functions still apply. If you pass a value type to a
   function, and call a pointer receiver method on the passed value, you are invoking the method on a copy
-- if you change the copy of the pointer, you haven’t changed the original. This means => you can’t write a pointer
   receiver method that handles nil and makes the original pointer non-nil. If your method has a pointer receiver 
   and won’t work for a nil receiver, check for nil and return an error


************************************************************************* 
************************** Composition & Inheritance ********************
*************************************************************************

- Type Declarations Aren’t Inheritance: 
    In languages with inheritance, a child instance can be used anywhere the parent instance is used. 
    The child instance also has all of the methods and data structures of the parent instance. That’s not the 
    case in Go. You cannot assign an instance of type HighScore to a variable of type Score or vice versa without 
    a type conversion, nor can you assign either of them to a variable of type int without a type conversion. 
    Furthermore, any methods defined on Score aren’t defined on HighScore

- The concept of iota comes from the programming language APL (which stood for “A
    Programming Language”). APL is famous for being so reliant on its own custom notation that
    it required computers with a special keyboard. For example, (~R∊R∘.×R)/R←1↓ιR is an APL
    program to find all the prime numbers up to the value of the variable R.

-- Furthermore, there is no dynamic dispatch for concrete types in Go. The methods on the embedded field have 
    no idea they are embedded. If you have a method on an embedded field that calls another method on the 
    embedded field, and the containing struct has a method of the same name, the method on the
    embedded field will not invoke the method on containing struct. 


************************************************************************* 
******************************** Interfaces *****************************
*************************************************************************

-- Sometimes in a statically typed language, you need a way to say that a variable
    could store a value of any type. Go uses interface{} to represent this any
-- One common use of the empty interface is as a placeholder for data of
    uncertain schema that’s read from an external source, like a JSON file

-- Since the purpose of a type switch is to derive a new variable from an existing one, it is
   idiomatic to assign the variable being switched on to a variable of the same name (i := i. (type)),
   making this one of the few places where shadowing is a good idea. 


************************************************************************* 
********************************** Errors *******************************
*************************************************************************
When using custom errors, never define a variable to be of the type of your custom error.
Either explicitly return nil when no error occurs or define the variable to be of type error.

-- Wrapping errors
   When an error is passed back through your code, you often want to add additional context to it. This 
   context can be the name of the function that received the error or the operation it was trying to 
   perform. When you preserve an error while adding additional information, it is called wrapping the error.
   When you have a series of wrapped errors, it is called an error chain
-- If you want to create a new error that contains the message from another error, but don’t want
      to wrap it, use fmt.Errorf to create an error, but use the %v verb instead of %w
