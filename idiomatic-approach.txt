For example, if you are currently running version 1.15.2 and wanted to try out 
version 1.15.6 of Go, you would use the following commands: 
                       ╭────────────────────────────────╮
                       │ go get golang.org/dl/go.1.15.6 │
                       │ go1.15.6 download              │
                       ╰────────────────────────────────╯
and then as normal:               go1.15.6 build 
Once you have validated that your code works on this versoin of go, if you wanna delete it: 
             ╭───────────────────────────────────────────────────────╮
             │ go1.15.6 env GOROOT     => /Users/gobook/sdk/go1.15.6 │
             │ rm -rf $(go1.15.6 env GOROOT)                         │
             │ rm $(go env GOPATH)/bin/go1.15.6                      │
             ╰───────────────────────────────────────────────────────╯

                       to update go version  on linux 
             ╭────────────────────────────────────────────────────╮
             │ mv /usr/local/go /usr/local/old-go     #backup     │
             │ tar -C /usr/local -xzf go1.15.2.linux-amd64.tar.gz │
             │ rm -rf /usr/local/old-go                           │
             ╰────────────────────────────────────────────────────╯



2-primitive-types-and-declarations

********************************* Integers ********************************* 
the zero value for all of the integer types is 0
          ╭────────────────────────────────────────────────────────────╮
          │ type name value range                                      │
          │ int8           -128 to 127                                 │
          │ int16          -32768 to 32767                             │
          │ int32          -2147483648 to 2147483647                   │
          │ int64          -9223372036854775808 to 9223372036854775807 │
          │ uint8           0 to 255                                   │
          │ uint16          0 to 65536                                 │
          │ uint32          0 to 4294967295                            │
          │ uint64          0 to 18446744073709551615                  │
          │                                                            │
          ╰────────────────────────────────────────────────────────────╯
          
the zero value for the floating point types is 0
type name    largest absolute value                         smallest (non-zero) absolute value
float32      3.40282346638528859811704183484516925440e+38    1.401298464324817070923729583289916131280e-45
float64      1.797693134862315708145274237317043567981e+308  4.940656458412465441765687928682213723651e-324

dividing a non-zero floating-point variable by 0 returns +Inf or -Inf (positive ornegative infinity),
depending on the sign of the number. Dividing a floating-point variable set to 0 by 0 returns NaN 

Go store floating point numbers using a specification called IEEE 754
For example, if you store the number -3.1415 in a float64, the 64-bit representation in memory looks like:
1100000000001001001000011100101011000000100000110001001001101111
which is exactly equal to: -3.14150000000000018118839761883.


********************************* Strings ********************************* 
1- Strings in Go are immutable; you can reassign the value of a string variable, but
you cannot change the value of the string that is assigned to it.
2- String in Go is made out of runes, but that’s not the case. Under the covers, Go uses a sequence of
bytes to represent a string. These bytes don’t have to be in any particular character encoding, 
but several Go library functions (and the for-range loop ) assume that
a string is composed of a sequence of UTF-8-encoded code points

********************************* Variables declaration ********************************* 
There are some situations within functions where you should avoid :=:
1- When initializing a variable to its zero value, use varmakes it clear that the zero value is intended.
2- While it is legal to use a type conversion to specify the type of the value and use := to
write x := byte(20), it is idiomatic to write var x byte = 20
3- Because := allows you to assign to both new and existing variables, it sometimes creates
new variables when you think you are re-using existing ones

********************************* Constants and immutablity ********************************* 
const in Go is very limited. Constants in Go are a way to give names to literals. They can only
hold values that the compiler can figure out at compile-time. This means that they can be assigned
Go doesn’t provide a way to specify that a value calculated at runtime is immutable there are no 
immutable arrays, slices, maps, or structs, and there’s no way to declare that a field in a struct is immutable
constants in Go are calculated at compile time and cannot have any side-effects. This makes 
them easy to eliminate; if a constant isn’t used, it is simply not included in the compiled binary

// Any Unicode character that is considered a letter or digit is allowed


********************************* Arrays ********************************* 
arrays in Go are rarely used explicitly. This is because they come with an unusual limitation: 
Go considers the size of the array to be part of the type of the array. This makes an array that’s declared 
to be [3]int a different type from an array that’s declared to be [4]int. This also means that you cannot 
use a variable to specify the size of an array, because types must be resolved at compile time, not at runtime

********************************* Slices ********************************* 
a slice is a sequence of values. Each element in a slice is assigned to consecutive memory locations, 
which makes it quick to read or write these values,  Every slice has a capacity, which is the number of 
consecutive memory locations reserved. This can be larger than the length. Each time you append to a slice,
one or more values is added to the end of the slice. Each value added increases the length by one. When the 
length reaches the capacity, there’s no more room to put values. If you try to add additional values when the length
equals the capacity, the append function uses the Go runtime to allocate a new slice with a larger capacity.
The values in the original slice are copied to the new slice, the new values are added to the end,
and the new slice is returned
Whenever you take a slice from another slice, the subslice’s capacity is set to the capacity of the 
original slice, minus the offset of the subslice within the original slice. This means that any 
unused capacity in the original slice is also shared with any subslices.


                                 THE GO RUNTIME
Every high-level language relies on a set of libraries to enable programs written in those languages to run,
and Go is no exception. The Go runtime provides services like memory allocation and garbage collection,
concurrency support, networking, and implementations of built-in types and functions. The Go runtime is 
compiled into every Go binary. This is different from languages that use a virtual machine, which must be 
installed separately to allow programs written in those languages to function. Including the runtime in the
binary makes it easier to distribute Go programs and avoids worries about compatibility issues between 
the runtime and the program.
When a slice grows via append, it takes time for the Go runtime to allocate new memory and copy the existing 
data from the old memory to the new. The old memory also needs to be garbage collected. For this reason, The Go
runtime usually increases a slice by more than one each time it runs out of capacity. The rules as of Go
1.14 are to double the size of the slice when the capacity is less than 1024,
and then grow by at least 25% afterwards.


