For example, if you are currently running version 1.15.2 and wanted to try out 
version 1.15.6 of Go, you would use the following commands: 
                       ╭────────────────────────────────╮
                       │ go get golang.org/dl/go.1.15.6 │
                       │ go1.15.6 download              │
                       ╰────────────────────────────────╯
and then as normal:               go1.15.6 build 
Once you have validated that your code works on this versoin of go, if you wanna delete it: 
             ╭───────────────────────────────────────────────────────╮
             │ go1.15.6 env GOROOT     => /Users/gobook/sdk/go1.15.6 │
             │ rm -rf $(go1.15.6 env GOROOT)                         │
             │ rm $(go env GOPATH)/bin/go1.15.6                      │
             ╰───────────────────────────────────────────────────────╯

                       to update go version  on linux 
             ╭────────────────────────────────────────────────────╮
             │ mv /usr/local/go /usr/local/old-go     #backup     │
             │ tar -C /usr/local -xzf go1.15.2.linux-amd64.tar.gz │
             │ rm -rf /usr/local/old-go                           │
             ╰────────────────────────────────────────────────────╯



2-primitive-types-and-declarations

********************************* Integers ********************************* 
the zero value for all of the integer types is 0
          ╭────────────────────────────────────────────────────────────╮
          │ type name value range                                      │
          │ int8           -128 to 127                                 │
          │ int16          -32768 to 32767                             │
          │ int32          -2147483648 to 2147483647                   │
          │ int64          -9223372036854775808 to 9223372036854775807 │
          │ uint8           0 to 255                                   │
          │ uint16          0 to 65536                                 │
          │ uint32          0 to 4294967295                            │
          │ uint64          0 to 18446744073709551615                  │
          │                                                            │
          ╰────────────────────────────────────────────────────────────╯
          
the zero value for the floating point types is 0
type name    largest absolute value                         smallest (non-zero) absolute value
float32      3.40282346638528859811704183484516925440e+38    1.401298464324817070923729583289916131280e-45
float64      1.797693134862315708145274237317043567981e+308  4.940656458412465441765687928682213723651e-324

dividing a non-zero floating-point variable by 0 returns +Inf or -Inf (positive ornegative infinity),
depending on the sign of the number. Dividing a floating-point variable set to 0 by 0 returns NaN 

Go store floating point numbers using a specification called IEEE 754
For example, if you store the number -3.1415 in a float64, the 64-bit representation in memory looks like:
1100000000001001001000011100101011000000100000110001001001101111
which is exactly equal to: -3.14150000000000018118839761883.


********************************* Strings ********************************* 
1- Strings in Go are immutable; you can reassign the value of a string variable, but
you cannot change the value of the string that is assigned to it.
2- String in Go is made out of runes, but that’s not the case. Under the covers, Go uses a sequence of
bytes to represent a string. These bytes don’t have to be in any particular character encoding, 
but several Go library functions (and the for-range loop ) assume that
a string is composed of a sequence of UTF-8-encoded code points

WARNING
Even though Go allows you to use slicing and indexing syntax with strings, you should only
use it when you know that your string only contains characters that take up one byte.

UTF-8  
UTF-8 is the most commonly used encoding for Unicode. Unicode uses 4 bytes (32-bits) to represent each code 
point, the technical name for each character and modifier. Given this, the simplest way to represent Unicode
code points is to store 4 bytes for each code point. This is called UTF-32. It is mostly unused because it wastes 
so much space. Due to Unicode implementation details, 11 of the 32 bits are always zero. Another common encoding 
is UTF-16, which uses one or two 16-bit (two byte) sequences to represent each code point. This is also wasteful; 
much of the content in the world is written using code points that fit into a single byte. And that’s where 
UTF-8 comes in.  UTF-8 is very clever. It lets you use a single byte to represent the Unicode
characters whose values are below 128 (which includes all of the letters, numbers, and punctuation commonly
used in English), but expands to a maximum of 4 bytes to represent Unicode code points with larger values.
The result is that the worst case for UTF-8 is the same as using UTF-32.  UTF-8 has some other nice properties.
Unlike UTF-32 and UTF-16, you don’t have to worry about little-endian vs. big-endian. It also allows you to
look at any byte in a sequence and tell if you are at the start of a UTF-8 sequence, or somewhere in the middle.
That means you can’t accidentally read a character incorrectly.  The only downside is that you cannot randomly 
access a string encoded with UTF-8, While you can detect if you are in the middle of a character, you
can’t tell how many characters in you are. You need to start at the beginning of the string and count. Go 
doesn’t require a string to be written in UTF-8, but it strongly encourages it. We’ll see how to work with 
UTF-8 strings in upcoming chapters. UTF-8 was invented in 1992 by Ken Thompson and Rob Pike, two of the creators of Go.

********************************* Variables declaration ********************************* 
There are some situations within functions where you should avoid :=:
1- When initializing a variable to its zero value, use var makes it clear that the zero value is intended.
2- While it is legal to use a type conversion to specify the type of the value and use := to
write x := byte(20), it is idiomatic to write var x byte = 20
3- Because := allows you to assign to both new and existing variables, it sometimes creates
new variables when you think you are re-using existing ones

********************************* Constants and immutability ********************************* 
const in Go is very limited. Constants in Go are a way to give names to literals. They can only
hold values that the compiler can figure out at compile-time. This means that they can be assigned
Go doesn’t provide a way to specify that a value calculated at runtime is immutable there are no 
immutable arrays, slices, maps, or struts, and there’s no way to declare that a field in a struck is immutable
constants in Go are calculated at compile time and cannot have any side-effects. This makes 
them easy to eliminate; if a constant isn’t used, it is simply not included in the compiled binary

// Any Unicode character that is considered a letter or digit is allowed


********************************* Arrays ********************************* 
arrays in Go are rarely used explicitly. This is because they come with an unusual limitation: 
Go considers the size of the array to be part of the type of the array. This makes an array that’s declared 
to be [3]int a different type from an array that’s declared to be [4]int. This also means that you cannot 
use a variable to specify the size of an array, because types must be resolved at compile time, not at runtime

********************************* Slices ********************************* 
a slice is a sequence of values. Each element in a slice is assigned to consecutive memory locations, 
which makes it quick to read or write these values,  Every slice has a capacity, which is the number of 
consecutive memory locations reserved. This can be larger than the length. Each time you append to a slice,
one or more values is added to the end of the slice. Each value added increases the length by one. When the 
length reaches the capacity, there’s no more room to put values. If you try to add additional values when the length
equals the capacity, the append function uses the Go runtime to allocate a new slice with a larger capacity.
The values in the original slice are copied to the new slice, the new values are added to the end,
and the new slice is returned
Whenever you take a slice from another slice, the subslice’s capacity is set to the capacity of the 
original slice, minus the offset of the subslice within the original slice. This means that any 
unused capacity in the original slice is also shared with any subslices.


                                 THE GO RUNTIME
Every high-level language relies on a set of libraries to enable programs written in those languages to run,
and Go is no exception. The Go runtime provides services like memory allocation and garbage collection,
concurrency support, networking, and implementations of built-in types and functions. The Go runtime is 
compiled into every Go binary. This is different from languages that use a virtual machine, which must be 
installed separately to allow programs written in those languages to function. Including the runtime in the
binary makes it easier to distribute Go programs and avoids worries about compatibility issues between 
the runtime and the program.
When a slice grows via append, it takes time for the Go runtime to allocate new memory and copy the existing 
data from the old memory to the new. The old memory also needs to be garbage collected. For this reason, The Go
runtime usually increases a slice by more than one each time it runs out of capacity. The rules as of Go
1.14 are to double the size of the slice when the capacity is less than 1024,
and then grow by at least 25% afterwards.


